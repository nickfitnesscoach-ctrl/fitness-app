# P1.5: AI Processing Event Architecture Refactoring

**Status**: Planned (non-urgent)
**Priority**: P1.5 (technical debt cleanup)
**Created**: 2026-01-14
**Author**: Tech Lead Review

## Context

Current implementation uses global `window.dispatchEvent` for AI photo processing events (`ai:photo-success`, `ai:photo-failed`). This works but creates risks:

### Current Architecture (P0 - Working)

```
useFoodBatchAnalysis (on SUCCESS/FAILED)
    ↓
window.dispatchEvent('ai:photo-success' | 'ai:photo-failed')
    ↓
ClientDashboard (useEffect listener)
    ↓
dailyMeals.refresh()
```

### Known Risks

1. **StrictMode Duplicate Events**: React StrictMode in DEV can mount/unmount effects twice → potential double refresh
2. **Hidden Subscriptions**: Global events make it hard to track who's listening
3. **Memory Leaks**: Easy to forget cleanup (`removeEventListener`)
4. **Race Conditions**: Multiple components listening to same event → unpredictable order
5. **Debug Difficulty**: No single place to see event flow

### Current Mitigations (P0-3)

✅ **Anti-duplicate protection** (2s window per taskId) in `ClientDashboard.tsx`
- Prevents double refresh from StrictMode
- Uses `useRef` to track last processed event
- Logs duplicates for debugging

```typescript
const lastProcessedEventRef = useRef<{ taskId: string; timestamp: number } | null>(null);

// In event handler:
if (lastEvent && lastEvent.taskId === taskId && now - lastEvent.timestamp < 2000) {
    console.log('[Dashboard] Ignoring duplicate event for taskId:', taskId);
    return;
}
```

## Target Architecture (P1.5)

### Option A: SSOT Context Pattern (Recommended)

```
useFoodBatchAnalysis (on SUCCESS/FAILED)
    ↓
invalidateDailyMeals(date) — single function passed via context/DI
    ↓
dailyMeals.refresh() — controlled by context
```

**Implementation**:

1. **Create `AIProcessingContext`**:
```typescript
// contexts/AIProcessingContext.tsx
interface AIProcessingContextValue {
    invalidateDailyMeals: (date: Date) => void;
}

export const AIProcessingProvider: React.FC = ({ children }) => {
    const invalidateDailyMeals = useCallback((date: Date) => {
        // Trigger refresh for specific date
        // Can add debouncing here (500-800ms for batch uploads)
    }, []);

    return (
        <AIProcessingContext.Provider value={{ invalidateDailyMeals }}>
            {children}
        </AIProcessingContext.Provider>
    );
};
```

2. **Update `useFoodBatchAnalysis`**:
```typescript
const { invalidateDailyMeals } = useAIProcessing();

if (normalized === 'SUCCESS') {
    const mapped = mapToAnalysisResult(status);
    invalidateDailyMeals(new Date()); // Or pass date from context
    return mapped;
}

if (normalized === 'FAILED') {
    invalidateDailyMeals(new Date());
    throw e;
}
```

3. **Remove window events from `ClientDashboard.tsx`**:
```typescript
// Delete entire useEffect with window.addEventListener
// Context handles refresh automatically
```

**Benefits**:
- ✅ No global events
- ✅ Explicit dependencies (visible in React DevTools)
- ✅ Type-safe
- ✅ Easy to add debouncing for batch uploads
- ✅ Testable (mock context)

### Option B: Custom Event Bus with Typed Events

If global events are needed for other reasons (e.g., cross-boundary communication):

```typescript
// utils/eventBus.ts
class TypedEventBus {
    private handlers = new Map<string, Set<Function>>();

    on<T>(event: string, handler: (detail: T) => void): () => void {
        // Register handler, return cleanup function
    }

    emit<T>(event: string, detail: T): void {
        // Dispatch to all handlers
    }
}

export const eventBus = new TypedEventBus();
```

**Benefits**:
- ✅ Type-safe events
- ✅ Centralized event management
- ✅ Automatic cleanup tracking

**Drawbacks**:
- ❌ Still global state
- ❌ Not idiomatic React

## Implementation Plan

### P1.5-1: Create SSOT Context (30 min)

1. Create `contexts/AIProcessingContext.tsx`
2. Add `invalidateDailyMeals(date)` function
3. Wrap app in `<AIProcessingProvider>`

### P1.5-2: Update AI Hook (15 min)

1. Replace `window.dispatchEvent` with `invalidateDailyMeals()`
2. Pass date from context or compute from meals

### P1.5-3: Remove Window Events (10 min)

1. Delete `useEffect` with `window.addEventListener` from `ClientDashboard.tsx`
2. Delete `lastProcessedEventRef` (no longer needed)

### P1.5-4: Add Debouncing (Optional, 15 min)

For batch uploads (multiple photos), add debouncing:

```typescript
const invalidateDailyMeals = useDebouncedCallback((date: Date) => {
    dailyMeals.refresh();
}, 500); // Wait 500ms after last event
```

**Note**: Only needed if users frequently upload 3+ photos in quick succession.

## Testing Plan

### Before Refactoring

1. ✅ SUCCESS → meal appears, diary updates
2. ✅ FAILED → error card appears, diary updates
3. ✅ Timeout → polling stops after max attempts
4. ✅ No double refresh in StrictMode (anti-duplicate protection)

### After Refactoring

1. Verify same scenarios work
2. Test batch upload (3+ photos) → single refresh after all complete
3. Verify no StrictMode issues (context is mount-safe)
4. Check React DevTools → context updates visible

## Rollout Strategy

**Non-urgent**: Current system is stable with P0-3 mitigations.

**When to do**:
- Before adding more AI features (photo retry, batch delete, etc.)
- When technical debt sprint is scheduled
- When onboarding new frontend developer (good codebase tour)

**Estimated effort**: 1-1.5 hours (including testing)

## Alternative: Keep Current Implementation

If P1.5 never happens, ensure:

1. ✅ Anti-duplicate protection stays (2s window per taskId)
2. ✅ Comprehensive logging (`console.log` on every event)
3. ⚠️ Document risk in code comments
4. ⚠️ Add unit tests for event handlers (mock `window.dispatchEvent`)

## References

- **Current implementation**: `frontend/src/features/ai/hooks/useFoodBatchAnalysis.ts:155-157, 166-168`
- **Event handler**: `frontend/src/pages/ClientDashboard.tsx:70-104`
- **Anti-duplicate logic**: `ClientDashboard.tsx:79-86`

## Decision Log

**2026-01-14**: Deferred to P1.5. Current implementation is production-ready with mitigations.
